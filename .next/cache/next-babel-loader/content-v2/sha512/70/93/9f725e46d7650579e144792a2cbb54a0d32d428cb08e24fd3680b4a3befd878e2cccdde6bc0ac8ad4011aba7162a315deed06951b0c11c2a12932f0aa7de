{"ast":null,"code":"import { useMotionValue, useDeprecatedInvertedScale } from 'framer-motion';\nimport { useEffect } from 'react';\n/**\n * Avoid the stretch/squashing of border radius by using inverting them\n * throughout the component's layout transition.\n *\n * It would be possible to animate to/from different radius, for instance\n * in mobile mode from rounded to square for full-screen panels, by passing\n * the calculated inverted transform to `layoutTransition` when set as a function.\n *\n * Those inverted scales could be provided here to act as a `from` value,\n * then we can use Popcorn's `mix` function to get our\n *\n * @param radius\n */\n\nexport function useInvertedBorderRadius(radius) {\n  const scaleX = useMotionValue(1);\n  const scaleY = useMotionValue(1);\n  const inverted = useDeprecatedInvertedScale({\n    scaleX,\n    scaleY\n  });\n  const borderRadius = useMotionValue(`${radius}px`);\n  useEffect(() => {\n    function updateRadius() {\n      const latestX = inverted.scaleX.get();\n      const latestY = inverted.scaleY.get();\n      const xRadius = latestX * radius + 'px';\n      const yRadius = latestY * radius + 'px';\n      borderRadius.set(`${xRadius} ${yRadius}`);\n    }\n\n    const unsubScaleX = inverted.scaleX.onChange(updateRadius);\n    const unsubScaleY = inverted.scaleY.onChange(updateRadius);\n    return () => {\n      unsubScaleX();\n      unsubScaleY();\n    };\n  }, [radius]);\n  return {\n    scaleX,\n    scaleY,\n    borderTopLeftRadius: borderRadius,\n    borderTopRightRadius: borderRadius,\n    borderBottomLeftRadius: borderRadius,\n    borderBottomRightRadius: borderRadius\n  };\n}","map":{"version":3,"sources":["/Users/fredo/Desktop/projects/sandbox-42/utils/use-inverted-border-radius.js"],"names":["useMotionValue","useDeprecatedInvertedScale","useEffect","useInvertedBorderRadius","radius","scaleX","scaleY","inverted","borderRadius","updateRadius","latestX","get","latestY","xRadius","yRadius","set","unsubScaleX","onChange","unsubScaleY","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"],"mappings":"AAAA,SAASA,cAAT,EAAyBC,0BAAzB,QAA2D,eAA3D;AACA,SAASC,SAAT,QAA0B,OAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,uBAAT,CAAiCC,MAAjC,EAAyC;AAC9C,QAAMC,MAAM,GAAGL,cAAc,CAAC,CAAD,CAA7B;AACA,QAAMM,MAAM,GAAGN,cAAc,CAAC,CAAD,CAA7B;AACA,QAAMO,QAAQ,GAAGN,0BAA0B,CAAC;AAAEI,IAAAA,MAAF;AAAUC,IAAAA;AAAV,GAAD,CAA3C;AACA,QAAME,YAAY,GAAGR,cAAc,CAAE,GAAEI,MAAO,IAAX,CAAnC;AAEAF,EAAAA,SAAS,CAAC,MAAM;AACd,aAASO,YAAT,GAAwB;AACtB,YAAMC,OAAO,GAAGH,QAAQ,CAACF,MAAT,CAAgBM,GAAhB,EAAhB;AACA,YAAMC,OAAO,GAAGL,QAAQ,CAACD,MAAT,CAAgBK,GAAhB,EAAhB;AACA,YAAME,OAAO,GAAGH,OAAO,GAAGN,MAAV,GAAmB,IAAnC;AACA,YAAMU,OAAO,GAAGF,OAAO,GAAGR,MAAV,GAAmB,IAAnC;AAEAI,MAAAA,YAAY,CAACO,GAAb,CAAkB,GAAEF,OAAQ,IAAGC,OAAQ,EAAvC;AACD;;AAED,UAAME,WAAW,GAAGT,QAAQ,CAACF,MAAT,CAAgBY,QAAhB,CAAyBR,YAAzB,CAApB;AACA,UAAMS,WAAW,GAAGX,QAAQ,CAACD,MAAT,CAAgBW,QAAhB,CAAyBR,YAAzB,CAApB;AAEA,WAAO,MAAM;AACXO,MAAAA,WAAW;AACXE,MAAAA,WAAW;AACZ,KAHD;AAID,GAjBQ,EAiBN,CAACd,MAAD,CAjBM,CAAT;AAmBA,SAAO;AACLC,IAAAA,MADK;AAELC,IAAAA,MAFK;AAGLa,IAAAA,mBAAmB,EAAEX,YAHhB;AAILY,IAAAA,oBAAoB,EAAEZ,YAJjB;AAKLa,IAAAA,sBAAsB,EAAEb,YALnB;AAMLc,IAAAA,uBAAuB,EAAEd;AANpB,GAAP;AAQD","sourcesContent":["import { useMotionValue, useDeprecatedInvertedScale } from 'framer-motion';\nimport { useEffect } from 'react';\n\n/**\n * Avoid the stretch/squashing of border radius by using inverting them\n * throughout the component's layout transition.\n *\n * It would be possible to animate to/from different radius, for instance\n * in mobile mode from rounded to square for full-screen panels, by passing\n * the calculated inverted transform to `layoutTransition` when set as a function.\n *\n * Those inverted scales could be provided here to act as a `from` value,\n * then we can use Popcorn's `mix` function to get our\n *\n * @param radius\n */\nexport function useInvertedBorderRadius(radius) {\n  const scaleX = useMotionValue(1);\n  const scaleY = useMotionValue(1);\n  const inverted = useDeprecatedInvertedScale({ scaleX, scaleY });\n  const borderRadius = useMotionValue(`${radius}px`);\n\n  useEffect(() => {\n    function updateRadius() {\n      const latestX = inverted.scaleX.get();\n      const latestY = inverted.scaleY.get();\n      const xRadius = latestX * radius + 'px';\n      const yRadius = latestY * radius + 'px';\n\n      borderRadius.set(`${xRadius} ${yRadius}`);\n    }\n\n    const unsubScaleX = inverted.scaleX.onChange(updateRadius);\n    const unsubScaleY = inverted.scaleY.onChange(updateRadius);\n\n    return () => {\n      unsubScaleX();\n      unsubScaleY();\n    };\n  }, [radius]);\n\n  return {\n    scaleX,\n    scaleY,\n    borderTopLeftRadius: borderRadius,\n    borderTopRightRadius: borderRadius,\n    borderBottomLeftRadius: borderRadius,\n    borderBottomRightRadius: borderRadius,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}